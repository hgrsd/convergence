# Web Frontend #

## Tech Stack ##

Cornerstone frontend libraries are [React](https://reactjs.org/), [Redux](https://redux.js.org/), [React Router](https://reacttraining.com/react-router/) and [Bootstrap](https://getbootstrap.com/).

We build our frontend with [Webpack](https://webpack.js.org/) and [Babel](https://babeljs.io/), our styles are written in [SCSS](https://sass-lang.com/documentation/syntax).

## Setting Up ##

- Before you start working on frontend, install NodeJS and npm.
- In terminal, navigate to the `static` folder:
```sh
cd convergence/static
```
- Run the webpack in watch mode:
```sh
npm start
```
- As long as this process is running, webpack will continuosly watch files from `convergence/static/src` and `convergence/static/style`, and rebuild distribution files upon any change.
- When a build is completed successfully, `convergence/static/dist/app.js` and `convergence/static/dist/index.css` files will be created or updated. You will have to refresh the browser page for the changes to take effect. NOTE: until issue #76 is resolved, you will need to refresh and clear cache (Cmd-Shift-R or Ctrl-F5 in Chrome).
- Navigate to `http://localhost:5000` or whatever address you've configured for your server. If all is well, you'll see a login form and no errors in browser console.

## Folder Structure ##

All things frontend are located in `root/convergence/static` folder.

- `static/index.html` is a frontend entry point. This file is returned by `/` route, and references compiled styles and javascript.
- `static/dist/` is a folder where compiled javascript (`app.js`) and styles (`index.css`) are located. Its contents are generated by Webpack, should not be edited nor comitted.
- `static/webpack.config.js` contains Webpack configuration. Webpack reads, translates and compiles sources from `static/src` and `static/style`, and outputs the result into `static/dist` folder.
- `static/webpack.confog.debug.js` is a webpack debug override. It's used when executing `npm start` or `npm run build-debug`.
- `static/src` contains all javascript sources in `.js` and `.jsx` files. This is where frontend logic and react components are defined.
- `static/src/index.jsx` is an entry point for the application. This is where redux store is assembled, and root component is rendered.
- `static/src/common` is a place to put common presentational (dumb) components. This is where buttons, spinners, and other simple reusable control components should go.

All other folders are supposed to follow `static/src/<module>` naming, where `<module>` is either a name of a main component for this submodule, or a functionality piece. For example, `static/src/login` module contains all things that have to do with authentication and registration: presentational and connected components, actions and a reducer.

It's possible to have nested modules where it makes sense. For example, `overview` might have an `events` submodule, which is responsible for rendering and interacting with events.

Each module should have an `index.js` entry point. This file is reponsible for connecting separate pieces of the module together and exporting things from the module. For example, `static/src/login/index.js` might create and export a connected component of a main login form, export its reducer and actions.

## Actions and Action Creators ##

Actions are defined as part of a most fitting module in its `actions.js`. Each action should have a type, which is an `UPPER_SNAKE_CASE` string constant, where the name of a constant is the same as its value. This constant should be exported, so it can be used in other parts of the application. For example:
```js
export const LOGIN_END = "LOGIN_END";
```

Actions, which can have an ending counterpart (open and close something, send request and receive response) should have `START` and `END` suffix. Fail action should have a `FAIL` suffix. For example:
```js
export const LOGIN_START = "LOGIN_START"; // kick off login routine
export const LOGIN_END = "LOGIN_END"; // logged in properly
export const LOGIN_FAIL = "LOGIN_FAIL"; // login failed
```

Action creator function is defined in the same file as `lowerPascalCase` function, which matches the action type name. It can take zero or more arguments to construct a payload. A simple action creator will return an action immediately:
```js
export function loginEnd() {
	return {
		type: LOGIN_END
	};
}

export function loginFail(errorMessage) {
	return {
		type: LOGIN_FAIL,
		errorMessage
	};
}
```

For cases, when an async operation needs to be kicked off by an action, we use [thunk](https://github.com/reduxjs/redux-thunk) middleware. In this case an action creator doesn't return a simple object, but instead it returns a function, which can dispatch multiple actions. For example:

```js
export function loginStart(username, password) {
	return dispatch => { // `dispatch` parameter is a function
		dispatch({ // dispatch a simple action
			type: LOGIN_START
		});

		const service = new ConvergenceService();
		service.loginStart(username, password) // perform an operation
			.then(resp => { // on promise resolve,
				dispatch(loginEnd()); // dispatch an action from a different creator
			}, err => { // on promise rejection,
				dispatch(loginFail(err.data.errorMessage)) // dispatch a failure action
			});
	}; // don't forget to return the whole thing
}
```

NOTE: Action creation will be affected by issue #71 resolution.

## State and Reducers ##

State is just a global JS object, which defines everything in the app, and is used by React components to render themselves. There's usually an initial (default) state, which gets modified by the reducer and actions into the current state. Our app splits state into smaller subtrees per major module. There's a `login` subtree, an `overview` subtree, and so on. They're combined together to make a single global object. Initial state for a subtree is defined as `initialState` variable in each module's `reducer.js`.

Reducer is a function, which takes in a state, an action, applies action to a state, and returns a new state. Reducers should never modify incoming state and action. Each state sub-tree has a separate reducer, defined in that module's `reducer.js` as an exported `<module>Reducer` function.

For example:

```js

const initialState = {
	loggingIn: false,
	errorMessage: null
};

export function loginReducer(state = initialState, action) {
	switch(action.type) {
		case LOGIN_START:
			// when this action comes in, we want to set `isLoggingIn` flag
			return {
				...state,
				isLoggingIn: true
			};
		case LOGIN_FAIL:
			// when this action comes in, we want to remove logging in flag
			// and set an error message
			return {
				...state,
				isLoggingIn: false,
				errorMessage: action.errorMessage
			};
		...
	}
	// return unmodified state if we didn't handle an action
	return state;
}
```

It's allowed to perform simple logic in the reducer, extract sub-routines and whatnot, as long as the reducer remains a pure function.

Every defined exported reducer is then imported by `static/src/index.jsx` and combined into a single app reducer.

## Components ##

Dumb (presentational) components are defined in `.jsx` files, and extend `React.Component` class. Major components should be exported. For example:

```jsx

export class EventList extends React.Component {
	render() {
		return (
			<div>
				this.props.events.map(ev => <EventCard event={event} />);
				<button onClick={() => this.props.eventCreateStart()} />
			</div>
		);
	}
}

class EventCard extends React.Component {
	render() {
		return (
			<div className="event-card">
				{this.props.event.name}
			</div>
		);
	}
}
```

Smart (container) components are wrappers, which connect dumb components and redux state. We define `mapStateToProps` and `mapDispatchToProps` functions in module's `index.js`, and feed these two mapping functions into `connect`.

`mapStateToProps` can return a state sub-tree directly or compose a more complicated strcuture from global state pieces. In `mapDispatchToProps` we use a corresponding action creator name as a function name. For example:

```js
import { eventCreateStart } from "./actions";
import { EventList } from "./event-list.jsx";
// ...

function mapStateToProps(state) {
	// out of the whole huge state tree,
	// extract an eventList sub-tree
	return state.overview.eventList;
}

function mapDispatchToProps(dispatch) {
	return {
		eventCreateStart: dispatch => {
			dispatch(eventCreateStart())
		}
	};
}

export default connect(mapStateToProps,
	mapDispatchToProps)(EventList);
```

